# Менеджмент зависимостей в PHP. Composer. Автозагрузка.

Сложно представить современную разработку без использования сторонних библиотек, выполняющих разную работу. Это компоненты кода, которые упрощают работу с сетью, датам, массивами, кэшем, базами данных и даже машинным обучением.

Сегодня мы имеем возможность сосредоточиться на задачах бизнеса и программного продукта, не отвлекаясь на написание велосипедов.

Библиотеки в свою очередь создают ряд новых проблем:
 - Версионирование. Библиотеки сами зависят от других библиотек, и эта цепочка может быть очень большой. Если в одной из библиотек меняется интерфейс или логика, то это изменение может каскадно обрушить весь пользовательский код.
 - Управление библиотеками. Добавлять, удалять, обновлять библиотеки и их зависимости вручную сложно.

 Для решения этих проблем используются менеджеры пакетов. В мире PHP он называется Composer.

## Установка Composer
Composer, по сути, такой-же PHP-скрипт, который можно установить глобально или использовать в качестве исполняемого файла.

[Инструкция по установке на официальном сайте](https://getcomposer.org/download/)

Скачиваем файл инсталлера:
```bash
php -r "copy('https://getcomposer.org/installer', 'composer-setup.php');"
```
Проверяем корректность данных:
```bash
php -r "if (hash_file('sha384', 'composer-setup.php') === '55ce33d7678c5a611085589f1f3ddf8b3c52d662cd01d4ba75c0ee0459970c2200a51f492d557530c71c15d8dba01eae') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"
```

Устанавливаем
```bash
php composer-setup.php
```

Удаляем установщик
```bash
php -r "unlink('composer-setup.php');"
```

Так-же рекомендуется перенести файл в директорию с бинарниками для того, чтобы иметь возможность использовать как консольную утилиту
```bash
sudo mv composer.phar /usr/local/bin/composer
```

## Использование

Для проверки корректности установки можно выполнить команду composer, она выведет логотип, версию и доступные команды
```bash
composer
```

Иницализация проекта в текущей директории. Композер задаст несколько вопросов, можно оставить всё по-умолчанию.
```bash
composer init
```

Установка [Guzzle](https://docs.guzzlephp.org/en/stable/overview.html#installation) - библиотеки для выполнения HTTP-запросов
```bash
composer require guzzlehttp/guzzle
```

В проекте появятся 2 файла конфигурации зависимостей и директория vendor:
- **composer.json** - Содержит информацию о проекте и его зависимостях, их версиях

- **composer.lock** - Фиксирует зависимости зависимостей, их версии.
Нужен для того, чтобы упорядочить их и избежать **Ада Зависимостей (Dependency Hell)**,
когда зависимости одних пакетов конфликтуют с зависимостями других.
При установке нового пакета или обновлении существующего происходит проверка всей цепочки

- **vendor** - дикретория, содержащая библиотеки, включенные в проект. Эту директорию **обязательно нужно включать в .gitignore** 

- **vendor/autoload.php** - файл, который нужно подключить в индексный файл вашего проекта, для того, чтобы было возможно использовать автозагрузку классов, как библиотек, так и ваших собственных

## Автозагрузка
В рабочих проектах устанавливается множество зависимостей и сама структура проекта может включать тысячи и десятки тысяч файлов.   
Для того, чтобы было проще включать одни файлы в другие был придуман механизм автозагрузки, позволяющий включать в код только те классы и функции, которые нужны.

Для подключения автозагрузки нужно включить в проект файл autoload.php, расположенный в директории vendor:
```php
<?php

require_once __DIR__ . '/vendor/autoload.php';
```

После этого можно подключить класс, который у нас появился при установке Guzzle:
```php
<?php

require_once __DIR__ . '/vendor/autoload.php';

use GuzzleHttp\Client;
```

Теперь возможно создать экземпляр класса и начать им пользоваться:
```php
<?php

require_once __DIR__ . '/vendor/autoload.php';

use GuzzleHttp\Client;

// Создание экземпляра класса
$client = new Client([
    'timeout'  => 2.0,
]);

// Отправке HTTP-запроса
$response = $client->get('https://api.thecatapi.com/v1/images/search');
```

## Автозагрузка собственных классов
Автозгарузка работает так-же и для кода проекта.
Например, создадим два класса: ```Advert``` в директории ```src/Model``` и ```Image``` в ```src/Model/Media```.

**В PHP принято писать ровно один класс в одном файле**
```php
<?php
// src/Model/Advert.php
namespace App\Model;

class Advert
{

}
```
```php
<?php
// src/Model/Media/Image.php
namespace App\Model\Media;

class Image
{
    private string $imageLink;

    public function __construct(string $imageLink)
    {
        $this->imageLink = $imageLink;
    }

    public function getLink(): string
    {
        return $this->imageLink;
    }
}
```
Обратите внимание на Неймспейс ```namespace App\Model;```
Он соответствует директории, в которой находится файл класса.

Если смотреть ещё внимательнее, можно обнаружить, что App и src имеют разные названия. Это поведение конфигурируется в файле ```composer.json```, где можно указать алиас для категории src:
```json
{
    "name": "chernyshev/package",
    "type": "project",
    "autoload": {
        "psr-4": {
            "App\\": "src/"
        }
    },
    "require": {
        "guzzlehttp/guzzle": "^7.5"
    }
}
```

### Подключаем один класс в другой
Для того, чтобы воспользоваться автозагруженными классами нужно указать их полный неймпсейс в начале файла с помощью ключевого слова ```use```

Обновим класс Advert и используем в нём класс Image
```php
<?php
// src/Model/Advert.php
namespace App\Model;

use App\Model\Media\Image;

class Advert
{
    private Image $image;

    public function setImage(Image $image)
    {
        $this->image = $image;
    }

    public function getThumbnail(): string
    {
        return $this->image ? $this->image->getLink() : '';
    }
}
```

Теперь можно создать объявление с изображением в index.php, в корне проекта.
Подключаем оба класса, создадим объекты, запускаем встроенный сервер ```php -S localhost:8000``` и выводим картинку:

```php
<?php
//index.php
$autoloadPath = __DIR__ . '/vendor/autoload.php';

require_once $autoloadPath;

use App\Model\Advert;
use App\Model\Media\Image;

$image  = new Image('https://cdn2.thecatapi.com/images/6ji.jpg');
$advert = new Advert();

$advert->setImage($image);

echo '<img src="' . $advert->getThumbnail() . '">';
```

Composer, автозагрузка и неймспейсы стали очень важными в мире PHP, они используются во всех современных проектах и знание как ими пользоваться - один из ключевых навыков PHP-программиста.