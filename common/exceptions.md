# Ошибки в программировании

> Как и почему мы ошибаемся?

## Что такое ошибка и какие они бывают?

>  Ошибка --- когда что-то не работает или работает не так, как надо

Есть разные способы классификации ошибок. В целях этой статьи, попробуем грубо поделить ошибки на несколько категорий:

- Ошибки в языке (синтаксические)
  - Если есть синтаксическая ошибка, из-за которой программа не компилируется\запускается
  - Больше применимо к компилируемым языкам
    - Go
    - Java
    - C#
    - и другие
- Runtime ошибки (ошибки времени исполнения)
  - Программа смогла запуститься, но из-за ошибки **завершилась** или не может продолжать исполнение
  - Примеры:
    - Выход за пределы массива
    - Ошибки с кастингом\преобразованием типов
    - и т.д.
- Логические ошибки
  - Ваша программа запускается, но работает не так, как задумывалось

## Инженерная ценность

Исправление ошибок требует времени и сил. Поэтому наша задача --- создавать такие системы, которые требует **наименьшего количества времени на исправление**

Если попробовать ранжировать их по требованию времени и сил, можно попробовать выделить такую иерархию:

1. Ошибки компиляции
1. Runtime ошибки
1. Логические ошибки


То есть самые простые для работы и исправления --- ошибки компиляции[^compilation-errors]. Тут есть компилятор --- он подсказывает что нужно исправить и исправление можно протестировать просто попробовав еще раз запустить программу.

Runtime ошибки --- чуть сложнее. Вам нужно запустить программу и запустить нужный сценарий. Но у таких ошибок есть отличная черта, они **очевидны**. То есть вы сразу можете понять, что что-то идет не так, ведь программа закрашилась и заставляет вас действовать

Логические ошибки --- ваша программа работает неправильно, и это **неочевидно**. Вы вынужденны в процессе использования сами заметить, что что-то идет не так. Например, у вас неправильно работает расчет остатка суммы на счете, но никаких ошибок не выходит, **программа продолжает работать неправильно**

В общем случае --- вы хотите приводить ошибки *вверх по этой иерархии*. 

> То есть, ваша задача, как инженера: превращать логические ошибки в Runtime ошибки, а Runtime ошибки, в ошибки компиляции, *настолько, насколько это возможно\разумно*

### Присказка

Я не знаю, насколько достоверна эта информация, но мне очень нравится посыл, поэтому приведу здесь ее:

В процессе разработки подземных шахт, раньше широко использовались деревянные опоры, чтобы шахта не обрушилась. Однако дерево очень подвержено различного рода физического воздействия, потому они были относительно недолговечны
Тем не менее, их использовали широко, пока в какой-то момент не решили заменить их на стальные балки, ведь они очень прочные, и смогут прослужить дольше, чем деревянные. Через какое-то время, работники попросили вернуть деревянные балки обратно. Работники могли слышать треск дерева и вовремя заменять их, в то вермя как стальные балки были непредсказуемы --- они стояли *действительно дольше, но ломались разом*, в итоге опасность для работников оказавылась выше, ведь вероятность остаться погребенным в шахте была дольше.

Таким образом мы приходим к важному выводу:

> Очевидно ломаться **лучше** чем неочевидно работать с ошибкой

Есть обратный, но имеющий ту же логику пример с канарейками: канарейки очень громкие, и постоянно щебечат. Когда происходила утечка газа, люди не успевали это определить, прежде чем умирали. Канарейки очень маленькие, поэтому травились быстрее, переставали щебетать и люди замечали, что им грозит опасность[^canary]

[^canary]: Похожим образом используют "[Канареечные показания](https://en.wikipedia.org/wiki/Warrant_canary)" в юриспруденции
[^compilation-errors]: Серьезный пункт в пользу компилируемых языков и почему на них предпочитают строить большие системы

## Как это делать?

Давайте представим простой кейс: вы хотите написать простую функцию, которая отдает номер элемента в массиве (псевдокод):

```go
func find(int element, int[] array) int {
    for (int i = 0; i < array.length; i++) {
        if (array[i] == element) {
            return i;
        }
        ???
    }
}
```

Вопросительными знаками здесь отмечен следующий момент: *что делать, если элемент не нашелся?*

Здесь есть несколько вариантов:

- Вернуть 0 или любое положительное число
  - Очевидно плохой вариант --- вы никогда не понимаете, завершилась ли работа корректно
- Вернуть -1 
  - Здесь это в целом разумно, но тоже не до конца очевидно: придется указывать в документации, и, будем честные, не все, кто пользуется вашей функцией ее прочитают
- Вернуть дополнительно информацию о том, что что-то пошло не так
  - Популярный способ в языках для системного программирования
  - Программист "на принимающей стороне" сможет сам обработать логику реагирования на ошибку
  - Сложно объединять несколько ошибок сразу (в nested вызовах)
  - Основной способ работы с ошибками в Go
- Завершить исполнение работы программы, соообщив об ошибке
  - Радикально, но далеко не самый худший вариант
  - Именно в этом цель механизма `исключений`\`exceptions`
  - Если на "принимающей стороне" есть возможность обработать эту ошибку --- *крайне желательный вариант*

> Как видите пример очень простой, и первые два варианта обработки --- подвязаны именно под логику работы с числами, в то время как последние два --- более унивесальны 

## Механизм исключений

> Данный раздел содержит сведения общего характера по самому механизму исключений в языках, которые его поддерживают

ВАЖНОЕ ПРИМЕЧАНИЕ: Здесь я пишу на псевдокоде, на выдуманном Си-подобном языке. Так как в Go нет исключений[^go-panic], а [статья с примером на PHP](../php/exceptions.md) вынесена отдельно.

[^go-panic]: Механизм `panic` в `Go` имеет другое смысловое наполнение и не может быть рассмотрен как полноценное исключение, даже если из нее тоже можно выйти в процессе выполнения программы

### Stack

Каждый раз, когда вы вызываете какой-то метод или функцию, большинство реализаций языков программирования, создают информацию о вызове новой функции и кладут ее в область в вашей оперативной памяти. Говоря более точно, они создают новый `frame`[^frame] для каждого вызова функций, который помещается в `stack` исполнения вашей программы 

[^frame]: Там программа хранит всякие локальные переменные и адрес инструкций, которые должны быть исполнены

`Stack` --- общее название специальных структур, реализованных таким образом, что новый элемент кладется "поверх" остальных, и можно вытащить только то, что "наверху". Представьте себе тарелки положенные друг на друга --- вы естественным образом кладете новую поверх, и достаете обратно их только сверху. Подробнее о стеках можно почитать [тут](https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D0%B5%D0%BA)

Представьте такой сценарий (псевдокод):
```go
func main() {
    first()
    fourth()
}

func first() {
    second()
}

func second() {
    third()
}

func third() {
    ... //do something
}

func fourth() {
    ... //do something
}
```

В таком случае, когда программа будет исполняться, будут исполнены следующие шаги:

```markdown
1. Вызов `main` создает новый элемент в стаке:

| Состояние стека |
|:---------------:|
|      main       |


2. Затем вызывается новая функция, `first`, новый фрейм кладется сверху
 
| Состояние стека |
|:---------------:|
|      first      |
|      main       |

3. `first` вызывает `second`

| Состояние стека |
|:---------------:|
|     second      |
|      first      |
|      main       |

4. `second` вызывает `third`

| Состояние стека |
|:---------------:|
|      third      |
|     second      |
|      first      |
|      main       |

5. ЕСЛИ `third` завершается успешно, то она убирается из стека:

| Состояние стека |
|:---------------:|
|     second      |
|      first      |
|      main       |

6. Теперь получается, что `second` тоже завершился, так как там нет других инструкций:

| Состояние стека |
|:---------------:|
|      first      |
|      main       |

7. `first` -- то же самое


| Состояние стека |
|:---------------:|
|      main       |

8. Теперь `main` может продолжить исполнение и вызывает `fourth`

| Состояние стека |
|:---------------:|
|     fourth      |
|      main       |

9. ЕСЛИ `fouth` завершился успешно, то он завершается и его фрейм уходит из стека

| Состояние стека |
|:---------------:|
|      main       |

10. И наконец завершается `main`. Завершение `main` --- завершает исполнение программы

| Состояние стека |
|:---------------:|

```

### Выброс исключения, уничтожаем все на своем пути!


Но что будет, если функция `third` завершиться некорректно. Например, если она "выбросит" `exception` (сама, или в результате внутренней логики). `Exception` играет роль "пушечного ядра", который будет **уничтожать все фреймы сверху вниз**


Псевдокод:

```go
func main() {
    first()
    fourth()
}

func first() {
    second()
}

func second() {
    third()
}

func third() {
    throw Exception();
}

func fourth() {
    ... //do something
}
```

Это будет выглядеть следующим образом:

```markdown
1. Вызов `main` создает новый элемент в стаке:

| Состояние стека |
|:---------------:|
|      main       |


2. Затем вызывается новая функция, `first`, новый фрейм кладется сверху
 
| Состояние стека |
|:---------------:|
|      first      |
|      main       |

3. `first` вызывает `second`

| Состояние стека |
|:---------------:|
|     second      |
|      first      |
|      main       |

4. `second` вызывает `third`

| Состояние стека |
|:---------------:|
|      third      |
|     second      |
|      first      |
|      main       |

5. `third` завершился аварийно! Он выбросил Exception, Exception уничтожил его frame:

| Состояние стека |
|:---------------:|
|     second      |
|      first      |
|      main       |


6. `second` не смог остановить это "ядро" и тоже завершился аварийно!

| Состояние стека |
|:---------------:|
|      first      |
|      main       |

7. `first` не смог остановить это "ядро" и тоже завершился аварийно!

| Состояние стека |
|:---------------:|
|      main       |


8. `main` не смог остановить это "ядро" и тоже завершился аварийно! Тем самым, остановилась наша программа

| Состояние стека |
|:---------------:|


То есть мы не можем продолжить исполнение в `main` --- программа завершилась и вызвать функцию `fouth` мы уже не можем
```

> Благодаря этому механизму, исключения "знают" на какой строке они случились и какая цепочка вызовов функций его породила, в большинстве языков, он пишет эту информацию при возникновении

### Ловим исключения --- выкручиваемся из ошибки и продолжаем работу

Если у нас есть возможность только ломать наши программы --- в этом механизме мало смысла. Поэтому, если язык поддерживает исключения, он поддерживает и способы их "поймать"

Псевдокод:

```go
func main() {
    try {
        first()
    } catch (Exception e) {
        print("Уф, я поймал!")
    }
    fourth()
}

func first() {
    second()
}

func second() {
    third()
}

func third() {
    throw Exception();
}

func fourth() {
    ... //do something
}
```


```markdown
1. Вызов `main` создает новый элемент в стаке:

| Состояние стека |
|:---------------:|
|      main       |


2. Затем вызывается новая функция, `first`, новый фрейм кладется сверху
 
| Состояние стека |
|:---------------:|
|      first      |
|      main       |

3. `first` вызывает `second`

| Состояние стека |
|:---------------:|
|     second      |
|      first      |
|      main       |

4. `second` вызывает `third`

| Состояние стека |
|:---------------:|
|      third      |
|     second      |
|      first      |
|      main       |

5. `third` завершился аварийно! Он выбросил Exception, Exception уничтожил его frame:

| Состояние стека |
|:---------------:|
|     second      |
|      first      |
|      main       |


6. `second` не смог остановить это "ядро" и тоже завершился аварийно!

| Состояние стека |
|:---------------:|
|      first      |
|      main       |

7. `first` не смог остановить это "ядро" и тоже завершился аварийно!

| Состояние стека |
|:---------------:|
|      main       |


8. `main` поймал исключение! Он исполняет логику внутри `catch` и печатает "Уф, я поймал".

| Состояние стека |
|:---------------:|
|      main       |


9. `main` продолжает работу и вызывает `fourth`

| Состояние стека |
|:---------------:|
|     fourth      |
|      main       |

10. ЕСЛИ `fouth` завершился успешно, то он завершается и его фрейм уходит из стека

| Состояние стека |
|:---------------:|
|      main       |

11. И наконец завершается `main`. Завершение `main` --- завершает исполнение программы

| Состояние стека |
|:---------------:|

```

Таким образом механизм `Исключений` --- позволяет нам бросать "ядра", ломающие все функции на нашем пути. Если его не остановить, он сломает `main` и программа остановиться. В то же самое время, мы можем поймать его на любом этапе и, словно кошка, перевернуться в падении и продолжить исполнение после опасного участка


## Как ими пользоваться?

Механизм исключений --- то самое, что может позволить вам превратить **логическую** ошибку в **Runtime** ошибку, тем самым упрощая вашу работу и удешевляя разработку.

То есть, если программа "ожидает" чего-то, что не исполняется, выбросить `Exception` --- разумный ход действий:

Пример на `Java`-подобном псевдокоде[^java-exceptions]

```java
class Person {
    private String name;
    private int age;

    public setAge(int newAge) {
        if (newAge < 0) {
            throw Exception("Возраст не может быть отрицательным!");
        } 
        age = newAge;
    }

    ...// Остальная логика
}
```

Таким образом мы можем гарантировать[^guarantee], что все объекты нашего `Person` будут иметь неотрицательный возраст, что помешает некорректному возрасту сломать нашу программу где-то в неожиданном месте в будущем[^accounting-age].


[^accounting-age]: Странный пример в вакууме: например, если возраст как-то учитывается в биллинге\оплате, отрицательное значение может сломать нам бухгалтерию. Пример немного глупый, но идея в том, что вы заранее не знаете, где вылезет эта проблема
[^java-exceptions]: Это был бы валидный код на Java, если бы бросался не `Exception`, а `RuntimeException`
[^guarantee]: Все еще можно изменить значение, если есть конструктор, не проверяющий этот случай или если язык владеет возможностью к `рефлексии`, но мы здесь не рассматриваем эти кейсы
